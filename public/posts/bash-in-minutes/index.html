<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>BASH in minutes | Elvis Finol</title>
<meta name=keywords content="bash">
<meta name=description content="Bash is a shell program. A shell program is typically an executable binary that takes commands that you type and (once you hit return), translates those commands into (ultimately) system calls to the Operating System API.
 Note: A binary is a file that contains the instructions for a program, ie it is a ‘program’ file, rather than a ‘text’ file, or an ‘application’ file (such as a Word document).">
<meta name=author content="Elvis Finol">
<link rel=canonical href=https://elvisfinol.com/posts/bash-in-minutes/>
<meta name=google-site-verification content="XYZabc">
<link href=/assets/css/stylesheet.min.03a9625f134ae9a90d2965368738004d05fe449a4be109663a1a80f4dba77687.css integrity="sha256-A6liXxNK6akNKWU2hzgATQX+RJpL4QlmOhqA9Nundoc=" rel="preload stylesheet" as=style>
<link rel=icon href=https://elvisfinol.com/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://elvisfinol.com/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://elvisfinol.com/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://elvisfinol.com/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://elvisfinol.com/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.4">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-123-45','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="BASH in minutes">
<meta property="og:description" content="Bash is a shell program. A shell program is typically an executable binary that takes commands that you type and (once you hit return), translates those commands into (ultimately) system calls to the Operating System API.
 Note: A binary is a file that contains the instructions for a program, ie it is a ‘program’ file, rather than a ‘text’ file, or an ‘application’ file (such as a Word document).">
<meta property="og:type" content="article">
<meta property="og:url" content="https://elvisfinol.com/posts/bash-in-minutes/">
<meta property="og:image" content="https://elvisfinol.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta property="article:published_time" content="2021-04-08T20:57:53+02:00">
<meta property="article:modified_time" content="2021-04-08T20:57:53+02:00"><meta property="og:site_name" content="Elvis Finol | Website">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://elvisfinol.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="BASH in minutes">
<meta name=twitter:description content="Bash is a shell program. A shell program is typically an executable binary that takes commands that you type and (once you hit return), translates those commands into (ultimately) system calls to the Operating System API.
 Note: A binary is a file that contains the instructions for a program, ie it is a ‘program’ file, rather than a ‘text’ file, or an ‘application’ file (such as a Word document).">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"BASH in minutes","name":"BASH in minutes","description":"Bash is a shell program. A shell program is typically an executable binary that takes commands that you type and (once you hit return), translates those commands into (ultimately) …","keywords":["bash"],"articleBody":"Bash is a shell program. A shell program is typically an executable binary that takes commands that you type and (once you hit return), translates those commands into (ultimately) system calls to the Operating System API.\n Note: A binary is a file that contains the instructions for a program, ie it is a ‘program’ file, rather than a ‘text’ file, or an ‘application’ file (such as a Word document).\n You only need to know that a shell program is a program that allows you to tell the computer what to do. In that way, it’s not much different to many other kinds of programming languages.\n#!/usr/bin/env bash # First line of the script is the shebang which tells the system how to execute # the script: https://en.wikipedia.org/wiki/Shebang_(Unix) # As you already figured, comments start with #. Shebang is also a comment. # Simple hello world example: echo Hello world! # = Hello world! # Each command starts on a new line, or after a semicolon: echo 'This is the first line'; echo 'This is the second line' # = This is the first line # = This is the second line # Declaring a variable looks like this: Variable=\"Some string\" # But not like this: Variable = \"Some string\" # = returns error \"Variable: command not found\" # Bash will decide that Variable is a command it must execute and give an error # because it can't be found. # Nor like this: Variable= 'Some string' # = returns error: \"Some string: command not found\" # Bash will decide that 'Some string' is a command it must execute and give an # error because it can't be found. (In this case the 'Variable=' part is seen # as a variable assignment valid only for the scope of the 'Some string' # command.) # Using the variable: echo $Variable # = Some string echo \"$Variable\" # = Some string echo '$Variable' # = $Variable # When you use the variable itself — assign it, export it, or else — you write # its name without $. If you want to use the variable's value, you should use $. # Note that ' (single quote) won't expand the variables! # Parameter expansion ${ }: echo ${Variable} # = Some string # This is a simple usage of parameter expansion # Parameter Expansion gets a value from a variable. # It \"expands\" or prints the value # During the expansion time the value or parameter can be modified # Below are other modifications that add onto this expansion # String substitution in variables echo ${Variable/Some/A} # = A string # This will substitute the first occurrence of \"Some\" with \"A\" # Substring from a variable Length=7 echo ${Variable:0:Length} # = Some st # This will return only the first 7 characters of the value echo ${Variable: -5} # = tring # This will return the last 5 characters (note the space before -5) # String length echo ${#Variable} # = 11 # Indirect expansion OtherVariable=\"Variable\" echo ${!OtherVariable} # = Some String # This will expand the value of OtherVariable # Default value for variable echo ${Foo:-\"DefaultValueIfFooIsMissingOrEmpty\"} # = DefaultValueIfFooIsMissingOrEmpty # This works for null (Foo=) and empty string (Foo=\"\"); zero (Foo=0) returns 0. # Note that it only returns default value and doesn't change variable value. # Declare an array with 6 elements array0=(one two three four five six) # Print first element echo $array0 # = \"one\" # Print first element echo ${array0[0]} # = \"one\" # Print all elements echo ${array0[@]} # = \"one two three four five six\" # Print number of elements echo ${#array0[@]} # = \"6\" # Print number of characters in third element echo ${#array0[2]} # = \"5\" # Print 2 elements starting from forth echo ${array0[@]:3:2} # = \"four five\" # Print all elements. Each of them on new line. for i in \"${array0[@]}\"; do echo \"$i\" done # Brace Expansion { } # Used to generate arbitrary strings echo {1..10} # = 1 2 3 4 5 6 7 8 9 10 echo {a..z} # = a b c d e f g h i j k l m n o p q r s t u v w x y z # This will output the range from the start value to the end value # Built-in variables: # There are some useful built-in variables, like echo \"Last program's return value: $?\" echo \"Script's PID: $$\" echo \"Number of arguments passed to script: $#\" echo \"All arguments passed to script: $@\" echo \"Script's arguments separated into different variables: $1 $2...\" # Now that we know how to echo and use variables, # let's learn some of the other basics of bash! # Our current directory is available through the command `pwd`. # `pwd` stands for \"print working directory\". # We can also use the built-in variable `$PWD`. # Observe that the following are equivalent: echo \"I'm in $(pwd)\" # execs `pwd` and interpolates output echo \"I'm in $PWD\" # interpolates the variable # If you get too much output in your terminal, or from a script, the command # `clear` clears your screen clear # Ctrl-L also works for clearing output # Reading a value from input: echo \"What's your name?\" read Name # Note that we didn't need to declare a new variable echo Hello, $Name! # We have the usual if structure: # use `man test` for more info about conditionals if [ $Name != $USER ] then echo \"Your name isn't your username\" else echo \"Your name is your username\" fi # True if the value of $Name is not equal to the current user's login username # NOTE: if $Name is empty, bash sees the above condition as: if [ != $USER ] # which is invalid syntax # so the \"safe\" way to use potentially empty variables in bash is: if [ \"$Name\" != $USER ] ... # which, when $Name is empty, is seen by bash as: if [ \"\" != $USER ] ... # which works as expected # There is also conditional execution echo \"Always executed\" || echo \"Only executed if first command fails\" # = Always executed echo \"Always executed\" \u0026\u0026 echo \"Only executed if first command does NOT fail\" # = Always executed # = Only executed if first command does NOT fail # To use \u0026\u0026 and || with if statements, you need multiple pairs of square brackets: if [ \"$Name\" == \"Steve\" ] \u0026\u0026 [ \"$Age\" -eq 15 ] then echo \"This will run if $Name is Steve AND $Age is 15.\" fi if [ \"$Name\" == \"Daniya\" ] || [ \"$Name\" == \"Zach\" ] then echo \"This will run if $Name is Daniya OR Zach.\" fi # There is also the `=~` operator, which tests a string against a Regex pattern: Email=me@example.com if [[ \"$Email\" =~ [a-z]+@[a-z]{2,}\\.(com|net|org) ]] then echo \"Valid email!\" fi # Note that =~ only works within double [[ ]] square brackets, # which are subtly different from single [ ]. # See https://www.gnu.org/software/bash/manual/bashref.html#Conditional-Constructs for more on this. # Redefine command `ping` as alias to send only 5 packets alias ping='ping -c 5' # Escape the alias and use command with this name instead \\ping 192.168.1.1 # Print all aliases alias -p # Expressions are denoted with the following format: echo $(( 10 + 5 )) # = 15 # Unlike other programming languages, bash is a shell so it works in the context # of a current directory. You can list files and directories in the current # directory with the ls command: ls # Lists the files and subdirectories contained in the current directory # This command has options that control its execution: ls -l # Lists every file and directory on a separate line ls -t # Sorts the directory contents by last-modified date (descending) ls -R # Recursively `ls` this directory and all of its subdirectories # Results of the previous command can be passed to the next command as input. # The `grep` command filters the input with provided patterns. # That's how we can list .txt files in the current directory: ls -l | grep \"\\.txt\" # Use `cat` to print files to stdout: cat file.txt # We can also read the file using `cat`: Contents=$(cat file.txt) # \"\\n\" prints a new line character # \"-e\" to interpret the newline escape characters as escape characters echo -e \"START OF FILE\\n$Contents\\nEND OF FILE\" # = START OF FILE # = [contents of file.txt] # = END OF FILE # Use `cp` to copy files or directories from one place to another. # `cp` creates NEW versions of the sources, # so editing the copy won't affect the original (and vice versa). # Note that it will overwrite the destination if it already exists. cp srcFile.txt clone.txt cp -r srcDirectory/ dst/ # recursively copy # Look into `scp` or `sftp` if you plan on exchanging files between computers. # `scp` behaves very similarly to `cp`. # `sftp` is more interactive. # Use `mv` to move files or directories from one place to another. # `mv` is similar to `cp`, but it deletes the source. # `mv` is also useful for renaming files! mv s0urc3.txt dst.txt # sorry, l33t hackers... # Since bash works in the context of a current directory, you might want to # run your command in some other directory. We have cd for changing location: cd ~ # change to home directory cd # also goes to home directory cd .. # go up one directory # (^^say, from /home/username/Downloads to /home/username) cd /home/username/Documents # change to specified directory cd ~/Documents/.. # still in home directory..isn't it?? cd - # change to last directory # = /home/username/Documents # Use subshells to work across directories (echo \"First, I'm here: $PWD\") \u0026\u0026 (cd someDir; echo \"Then, I'm here: $PWD\") pwd # still in first directory # Use `mkdir` to create new directories. mkdir myNewDir # The `-p` flag causes new intermediate directories to be created as necessary. mkdir -p myNewDir/with/intermediate/directories # if the intermediate directories didn't already exist, running the above # command without the `-p` flag would return an error # You can redirect command input and output (stdin, stdout, and stderr). # Read from stdin until ^EOF$ and overwrite hello.py with the lines # between \"EOF\": cat  hello.py \"output.out\" # redirect output from the script to output.out python hello.py 2 \"error.err\" # redirect error output to error.err python hello.py  \"output-and-error.log\" 2\u00261 # redirect both output and errors to output-and-error.log python hello.py  /dev/null 2\u00261 # redirect all output and errors to the black hole, /dev/null, i.e., no output # The output error will overwrite the file if it exists, # if you want to append instead, use \"\": python hello.py  \"output.out\" 2 \"error.err\" # Overwrite output.out, append to error.err, and count lines: info bash 'Basic Shell Features' 'Redirections'  output.out 2 error.err wc -l output.out error.err # Run a command and print its file descriptor (e.g. /dev/fd/123) # see: man fd echo output.out output.out echo \"#helloworld\" | cat  output.out echo \"#helloworld\" | tee output.out /dev/null # Cleanup temporary files verbosely (add '-i' for interactive) # WARNING: `rm` commands cannot be undone rm -v output.out error.err output-and-error.log rm -r tempDir/ # recursively delete # You can install the `trash-cli` Python package to have `trash` # which puts files in the system trash and doesn't delete them directly # see https://pypi.org/project/trash-cli/ if you want to be careful # Commands can be substituted within other commands using $( ): # The following command displays the number of files and directories in the # current directory. echo \"There are $(ls | wc -l) items here.\" # The same can be done using backticks `` but they can't be nested - # the preferred way is to use $( ). echo \"There are `ls | wc -l` items here.\" # Bash uses a `case` statement that works similarly to switch in Java and C++: case \"$Variable\" in # List patterns for the conditions you want to meet 0) echo \"There is a zero.\";; 1) echo \"There is a one.\";; *) echo \"It is not null.\";; # match everything esac # `for` loops iterate for as many arguments given: # The contents of $Variable is printed three times. for Variable in {1..3} do echo \"$Variable\" done # = 1 # = 2 # = 3 # Or write it the \"traditional for loop\" way: for ((a=1; a 1 # = 2 # = 3 # They can also be used to act on files.. # This will run the command `cat` on file1 and file2 for Variable in file1 file2 do cat \"$Variable\" done # ..or the output from a command # This will `cat` the output from `ls`. for Output in $(ls) do cat \"$Output\" done # Bash can also accept patterns, like this to `cat` # all the Markdown files in current directory for Output in ./*.markdown do cat \"$Output\" done # while loop: while [ true ] do echo \"loop body here...\" break done # = loop body here... # You can also define functions # Definition: function foo () { echo \"Arguments work just like script arguments: $@\" echo \"And: $1 $2...\" echo \"This is a function\" return 0 } # Call the function `foo` with two arguments, arg1 and arg2: foo arg1 arg2 # = Arguments work just like script arguments: arg1 arg2 # = And: arg1 arg2... # = This is a function # or simply bar () { echo \"Another way to declare functions!\" return 0 } # Call the function `bar` with no arguments: bar # = Another way to declare functions! # Calling your function foo \"My name is\" $Name # There are a lot of useful commands you should learn: # prints last 10 lines of file.txt tail -n 10 file.txt # prints first 10 lines of file.txt head -n 10 file.txt # sort file.txt's lines sort file.txt # report or omit repeated lines, with -d it reports them uniq -d file.txt # prints only the first column before the ',' character cut -d ',' -f 1 file.txt # replaces every occurrence of 'okay' with 'great' in file.txt # (regex compatible) sed -i 's/okay/great/g' file.txt # be aware that this -i flag means that file.txt will be changed # -i or --in-place erase the input file (use --in-place=.backup to keep a back-up) # print to stdout all lines of file.txt which match some regex # The example prints lines which begin with \"foo\" and end in \"bar\" grep \"^foo.*bar$\" file.txt # pass the option \"-c\" to instead print the number of lines matching the regex grep -c \"^foo.*bar$\" file.txt # Other useful options are: grep -r \"^foo.*bar$\" someDir/ # recursively `grep` grep -n \"^foo.*bar$\" file.txt # give line numbers grep -rI \"^foo.*bar$\" someDir/ # recursively `grep`, but ignore binary files # perform the same initial search, but filter out the lines containing \"baz\" grep \"^foo.*bar$\" file.txt | grep -v \"baz\" # if you literally want to search for the string, # and not the regex, use `fgrep` (or `grep -F`) fgrep \"foobar\" file.txt # The `trap` command allows you to execute a command whenever your script # receives a signal. Here, `trap` will execute `rm` if it receives any of the # three listed signals. trap \"rm $TEMP_FILE; exit\" SIGHUP SIGINT SIGTERM # `sudo` is used to perform commands as the superuser # usually it will ask interactively the password of superuser NAME1=$(whoami) NAME2=$(sudo whoami) echo \"Was $NAME1, then became more powerful $NAME2\" # Read Bash shell built-ins documentation with the bash `help` built-in: help help help help for help return help source help . # Read Bash manpage documentation with `man` apropos bash man 1 bash man bash # Read info documentation with `info` (`?` for help) apropos info | grep '^info.*(' man info info info info 5 info # Read bash info documentation: info bash info bash 'Bash Features' info bash 6 info --apropos bash Source https://learnxinyminutes.com/docs/bash/\n","wordCount":"2761","inLanguage":"en","datePublished":"2021-04-08T20:57:53+02:00","dateModified":"2021-04-08T20:57:53+02:00","author":{"@type":"Person","name":"Elvis Finol"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://elvisfinol.com/posts/bash-in-minutes/"},"publisher":{"@type":"Organization","name":"Elvis Finol","logo":{"@type":"ImageObject","url":"https://elvisfinol.com/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>.theme-toggle,.top-link{display:none}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a class=link-3 href=https://elvisfinol.com accesskey=h title="Elvis Finol (Alt + H)">
<img src=https://upload.wikimedia.org/wikipedia/commons/b/b3/Terminalicon2.png alt=logo aria-label=logo height=35>Elvis Finol</a>
<span class=logo-switches>
<span class=theme-toggle title="(Alt + T)">
<a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</a>
</span>
</span>
</div>
<ul class=menu id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://elvisfinol.com/aboutme/ title="About Me">
<span>About Me</span>
</a>
</li>
<li>
<a href=https://elvisfinol.com/archive/ title=Blog>
<span>Blog</span>
</a>
</li>
<li>
<a href=https://github.com/elvisfinol title=GitHub>
<span>GitHub</span>
</a>
</li>
<li>
<a href=https://www.linkedin.com/in/elvisfinol/ title=LinkedIn>
<span>LinkedIn</span>
</a>
</li>
<li>
<a href=https://elvisfinol-website-bucket.s3.eu-west-1.amazonaws.com/ELVIS-ENRIQUE-FINOL-ARRIETA-CV2.pdf title=Resume>
<span>Resume</span>
</a>
</li>
<li>
<a href=https://elvisfinol.com/search/ title=🔍>
<span>🔍</span>
</a>
</li></ul>
</nav>
<link rel=stylesheet href=https://use.fontawesome.com/releases/v5.15.1/css/all.css integrity=sha384-vp86vTRFVJgpjF9jiIGPEEqYqlDwgyBgEF109VFjmqGmIY/Y4HV4d3Gp2irVfcrp crossorigin=anonymous>
<link rel=preconnect href=https://fonts.gstatic.com>
<link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;500;600&family=Rubik:wght@300;500;600&display=swap" rel=stylesheet>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
BASH in minutes
</h1>
<div class=post-description>
</div>
<div class=post-meta>
April 8, 2021&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Elvis Finol
</div>
</header>
<div class=post-content>
<p><img src=https://i.imgur.com/9VqbD7I.jpg alt=BASH></p>
<h2 id=bash-is-a-shell-program>Bash is a shell program.<a hidden class=anchor aria-hidden=true href=#bash-is-a-shell-program>#</a></h2>
<p>A shell program is typically an executable binary that takes commands that you type and (once you hit return), translates those commands into (ultimately) system calls to the Operating System API.</p>
<blockquote>
<p>Note: A binary is a file that contains the instructions for a program, ie it is a ‘program’ file, rather than a ‘text’ file, or an ‘application’ file (such as a Word document).</p>
</blockquote>
<p>You only need to know that a shell program is a program that allows you to tell the computer what to do. In that way, it’s not much different to many other kinds of programming languages.</p>
<pre tabindex=0><code>#!/usr/bin/env bash
# First line of the script is the shebang which tells the system how to execute
# the script: https://en.wikipedia.org/wiki/Shebang_(Unix)
# As you already figured, comments start with #. Shebang is also a comment.

# Simple hello world example:
echo Hello world! # =&gt; Hello world!

# Each command starts on a new line, or after a semicolon:
echo 'This is the first line'; echo 'This is the second line'
# =&gt; This is the first line
# =&gt; This is the second line

# Declaring a variable looks like this:
Variable=&quot;Some string&quot;

# But not like this:
Variable = &quot;Some string&quot; # =&gt; returns error &quot;Variable: command not found&quot;
# Bash will decide that Variable is a command it must execute and give an error
# because it can't be found.

# Nor like this:
Variable= 'Some string' # =&gt; returns error: &quot;Some string: command not found&quot;
# Bash will decide that 'Some string' is a command it must execute and give an
# error because it can't be found. (In this case the 'Variable=' part is seen
# as a variable assignment valid only for the scope of the 'Some string'
# command.)

# Using the variable:
echo $Variable # =&gt; Some string
echo &quot;$Variable&quot; # =&gt; Some string
echo '$Variable' # =&gt; $Variable
# When you use the variable itself — assign it, export it, or else — you write
# its name without $. If you want to use the variable's value, you should use $.
# Note that ' (single quote) won't expand the variables!

# Parameter expansion ${ }:
echo ${Variable} # =&gt; Some string
# This is a simple usage of parameter expansion
# Parameter Expansion gets a value from a variable.
# It &quot;expands&quot; or prints the value
# During the expansion time the value or parameter can be modified
# Below are other modifications that add onto this expansion

# String substitution in variables
echo ${Variable/Some/A} # =&gt; A string
# This will substitute the first occurrence of &quot;Some&quot; with &quot;A&quot;

# Substring from a variable
Length=7
echo ${Variable:0:Length} # =&gt; Some st
# This will return only the first 7 characters of the value
echo ${Variable: -5} # =&gt; tring
# This will return the last 5 characters (note the space before -5)

# String length
echo ${#Variable} # =&gt; 11

# Indirect expansion
OtherVariable=&quot;Variable&quot;
echo ${!OtherVariable} # =&gt; Some String
# This will expand the value of OtherVariable

# Default value for variable
echo ${Foo:-&quot;DefaultValueIfFooIsMissingOrEmpty&quot;}
# =&gt; DefaultValueIfFooIsMissingOrEmpty
# This works for null (Foo=) and empty string (Foo=&quot;&quot;); zero (Foo=0) returns 0.
# Note that it only returns default value and doesn't change variable value.

# Declare an array with 6 elements
array0=(one two three four five six)
# Print first element
echo $array0 # =&gt; &quot;one&quot;
# Print first element
echo ${array0[0]} # =&gt; &quot;one&quot;
# Print all elements
echo ${array0[@]} # =&gt; &quot;one two three four five six&quot;
# Print number of elements
echo ${#array0[@]} # =&gt; &quot;6&quot;
# Print number of characters in third element
echo ${#array0[2]} # =&gt; &quot;5&quot;
# Print 2 elements starting from forth
echo ${array0[@]:3:2} # =&gt; &quot;four five&quot;
# Print all elements. Each of them on new line.
for i in &quot;${array0[@]}&quot;; do
    echo &quot;$i&quot;
done

# Brace Expansion { }
# Used to generate arbitrary strings
echo {1..10} # =&gt; 1 2 3 4 5 6 7 8 9 10
echo {a..z} # =&gt; a b c d e f g h i j k l m n o p q r s t u v w x y z
# This will output the range from the start value to the end value

# Built-in variables:
# There are some useful built-in variables, like
echo &quot;Last program's return value: $?&quot;
echo &quot;Script's PID: $$&quot;
echo &quot;Number of arguments passed to script: $#&quot;
echo &quot;All arguments passed to script: $@&quot;
echo &quot;Script's arguments separated into different variables: $1 $2...&quot;

# Now that we know how to echo and use variables,
# let's learn some of the other basics of bash!

# Our current directory is available through the command `pwd`.
# `pwd` stands for &quot;print working directory&quot;.
# We can also use the built-in variable `$PWD`.
# Observe that the following are equivalent:
echo &quot;I'm in $(pwd)&quot; # execs `pwd` and interpolates output
echo &quot;I'm in $PWD&quot; # interpolates the variable

# If you get too much output in your terminal, or from a script, the command
# `clear` clears your screen
clear
# Ctrl-L also works for clearing output

# Reading a value from input:
echo &quot;What's your name?&quot;
read Name # Note that we didn't need to declare a new variable
echo Hello, $Name!

# We have the usual if structure:
# use `man test` for more info about conditionals
if [ $Name != $USER ]
then
    echo &quot;Your name isn't your username&quot;
else
    echo &quot;Your name is your username&quot;
fi
# True if the value of $Name is not equal to the current user's login username

# NOTE: if $Name is empty, bash sees the above condition as:
if [ != $USER ]
# which is invalid syntax
# so the &quot;safe&quot; way to use potentially empty variables in bash is:
if [ &quot;$Name&quot; != $USER ] ...
# which, when $Name is empty, is seen by bash as:
if [ &quot;&quot; != $USER ] ...
# which works as expected

# There is also conditional execution
echo &quot;Always executed&quot; || echo &quot;Only executed if first command fails&quot;
# =&gt; Always executed
echo &quot;Always executed&quot; &amp;&amp; echo &quot;Only executed if first command does NOT fail&quot;
# =&gt; Always executed
# =&gt; Only executed if first command does NOT fail


# To use &amp;&amp; and || with if statements, you need multiple pairs of square brackets:
if [ &quot;$Name&quot; == &quot;Steve&quot; ] &amp;&amp; [ &quot;$Age&quot; -eq 15 ]
then
    echo &quot;This will run if $Name is Steve AND $Age is 15.&quot;
fi

if [ &quot;$Name&quot; == &quot;Daniya&quot; ] || [ &quot;$Name&quot; == &quot;Zach&quot; ]
then
    echo &quot;This will run if $Name is Daniya OR Zach.&quot;
fi

# There is also the `=~` operator, which tests a string against a Regex pattern:
Email=me@example.com
if [[ &quot;$Email&quot; =~ [a-z]+@[a-z]{2,}\.(com|net|org) ]]
then
    echo &quot;Valid email!&quot;
fi
# Note that =~ only works within double [[ ]] square brackets,
# which are subtly different from single [ ].
# See https://www.gnu.org/software/bash/manual/bashref.html#Conditional-Constructs for more on this.

# Redefine command `ping` as alias to send only 5 packets
alias ping='ping -c 5'
# Escape the alias and use command with this name instead
\ping 192.168.1.1
# Print all aliases
alias -p

# Expressions are denoted with the following format:
echo $(( 10 + 5 )) # =&gt; 15

# Unlike other programming languages, bash is a shell so it works in the context
# of a current directory. You can list files and directories in the current
# directory with the ls command:
ls # Lists the files and subdirectories contained in the current directory

# This command has options that control its execution:
ls -l # Lists every file and directory on a separate line
ls -t # Sorts the directory contents by last-modified date (descending)
ls -R # Recursively `ls` this directory and all of its subdirectories

# Results of the previous command can be passed to the next command as input.
# The `grep` command filters the input with provided patterns.
# That's how we can list .txt files in the current directory:
ls -l | grep &quot;\.txt&quot;

# Use `cat` to print files to stdout:
cat file.txt

# We can also read the file using `cat`:
Contents=$(cat file.txt)
# &quot;\n&quot; prints a new line character
# &quot;-e&quot; to interpret the newline escape characters as escape characters
echo -e &quot;START OF FILE\n$Contents\nEND OF FILE&quot;
# =&gt; START OF FILE
# =&gt; [contents of file.txt]
# =&gt; END OF FILE

# Use `cp` to copy files or directories from one place to another.
# `cp` creates NEW versions of the sources,
# so editing the copy won't affect the original (and vice versa).
# Note that it will overwrite the destination if it already exists.
cp srcFile.txt clone.txt
cp -r srcDirectory/ dst/ # recursively copy

# Look into `scp` or `sftp` if you plan on exchanging files between computers.
# `scp` behaves very similarly to `cp`.
# `sftp` is more interactive.

# Use `mv` to move files or directories from one place to another.
# `mv` is similar to `cp`, but it deletes the source.
# `mv` is also useful for renaming files!
mv s0urc3.txt dst.txt # sorry, l33t hackers...

# Since bash works in the context of a current directory, you might want to
# run your command in some other directory. We have cd for changing location:
cd ~    # change to home directory
cd      # also goes to home directory
cd ..   # go up one directory
        # (^^say, from /home/username/Downloads to /home/username)
cd /home/username/Documents   # change to specified directory
cd ~/Documents/..    # still in home directory..isn't it??
cd -    # change to last directory
# =&gt; /home/username/Documents

# Use subshells to work across directories
(echo &quot;First, I'm here: $PWD&quot;) &amp;&amp; (cd someDir; echo &quot;Then, I'm here: $PWD&quot;)
pwd # still in first directory

# Use `mkdir` to create new directories.
mkdir myNewDir
# The `-p` flag causes new intermediate directories to be created as necessary.
mkdir -p myNewDir/with/intermediate/directories
# if the intermediate directories didn't already exist, running the above
# command without the `-p` flag would return an error

# You can redirect command input and output (stdin, stdout, and stderr).
# Read from stdin until ^EOF$ and overwrite hello.py with the lines
# between &quot;EOF&quot;:
cat &gt; hello.py &lt;&lt; EOF
#!/usr/bin/env python
from __future__ import print_function
import sys
print(&quot;#stdout&quot;, file=sys.stdout)
print(&quot;#stderr&quot;, file=sys.stderr)
for line in sys.stdin:
    print(line, file=sys.stdout)
EOF
# Variables will be expanded if the first &quot;EOF&quot; is not quoted

# Run the hello.py Python script with various stdin, stdout, and
# stderr redirections:
python hello.py &lt; &quot;input.in&quot; # pass input.in as input to the script

python hello.py &gt; &quot;output.out&quot; # redirect output from the script to output.out

python hello.py 2&gt; &quot;error.err&quot; # redirect error output to error.err

python hello.py &gt; &quot;output-and-error.log&quot; 2&gt;&amp;1
# redirect both output and errors to output-and-error.log

python hello.py &gt; /dev/null 2&gt;&amp;1
# redirect all output and errors to the black hole, /dev/null, i.e., no output

# The output error will overwrite the file if it exists,
# if you want to append instead, use &quot;&gt;&gt;&quot;:
python hello.py &gt;&gt; &quot;output.out&quot; 2&gt;&gt; &quot;error.err&quot;

# Overwrite output.out, append to error.err, and count lines:
info bash 'Basic Shell Features' 'Redirections' &gt; output.out 2&gt;&gt; error.err
wc -l output.out error.err

# Run a command and print its file descriptor (e.g. /dev/fd/123)
# see: man fd
echo &lt;(echo &quot;#helloworld&quot;)

# Overwrite output.out with &quot;#helloworld&quot;:
cat &gt; output.out &lt;(echo &quot;#helloworld&quot;)
echo &quot;#helloworld&quot; &gt; output.out
echo &quot;#helloworld&quot; | cat &gt; output.out
echo &quot;#helloworld&quot; | tee output.out &gt;/dev/null

# Cleanup temporary files verbosely (add '-i' for interactive)
# WARNING: `rm` commands cannot be undone
rm -v output.out error.err output-and-error.log
rm -r tempDir/ # recursively delete
# You can install the `trash-cli` Python package to have `trash`
# which puts files in the system trash and doesn't delete them directly
# see https://pypi.org/project/trash-cli/ if you want to be careful

# Commands can be substituted within other commands using $( ):
# The following command displays the number of files and directories in the
# current directory.
echo &quot;There are $(ls | wc -l) items here.&quot;

# The same can be done using backticks `` but they can't be nested -
# the preferred way is to use $( ).
echo &quot;There are `ls | wc -l` items here.&quot;

# Bash uses a `case` statement that works similarly to switch in Java and C++:
case &quot;$Variable&quot; in
    # List patterns for the conditions you want to meet
    0) echo &quot;There is a zero.&quot;;;
    1) echo &quot;There is a one.&quot;;;
    *) echo &quot;It is not null.&quot;;;  # match everything
esac

# `for` loops iterate for as many arguments given:
# The contents of $Variable is printed three times.
for Variable in {1..3}
do
    echo &quot;$Variable&quot;
done
# =&gt; 1
# =&gt; 2
# =&gt; 3


# Or write it the &quot;traditional for loop&quot; way:
for ((a=1; a &lt;= 3; a++))
do
    echo $a
done
# =&gt; 1
# =&gt; 2
# =&gt; 3

# They can also be used to act on files..
# This will run the command `cat` on file1 and file2
for Variable in file1 file2
do
    cat &quot;$Variable&quot;
done

# ..or the output from a command
# This will `cat` the output from `ls`.
for Output in $(ls)
do
    cat &quot;$Output&quot;
done

# Bash can also accept patterns, like this to `cat`
# all the Markdown files in current directory
for Output in ./*.markdown
do
    cat &quot;$Output&quot;
done

# while loop:
while [ true ]
do
    echo &quot;loop body here...&quot;
    break
done
# =&gt; loop body here...

# You can also define functions
# Definition:
function foo ()
{
    echo &quot;Arguments work just like script arguments: $@&quot;
    echo &quot;And: $1 $2...&quot;
    echo &quot;This is a function&quot;
    return 0
}
# Call the function `foo` with two arguments, arg1 and arg2:
foo arg1 arg2
# =&gt; Arguments work just like script arguments: arg1 arg2
# =&gt; And: arg1 arg2...
# =&gt; This is a function

# or simply
bar ()
{
    echo &quot;Another way to declare functions!&quot;
    return 0
}
# Call the function `bar` with no arguments:
bar # =&gt; Another way to declare functions!

# Calling your function
foo &quot;My name is&quot; $Name

# There are a lot of useful commands you should learn:
# prints last 10 lines of file.txt
tail -n 10 file.txt

# prints first 10 lines of file.txt
head -n 10 file.txt

# sort file.txt's lines
sort file.txt

# report or omit repeated lines, with -d it reports them
uniq -d file.txt

# prints only the first column before the ',' character
cut -d ',' -f 1 file.txt

# replaces every occurrence of 'okay' with 'great' in file.txt
# (regex compatible)
sed -i 's/okay/great/g' file.txt
# be aware that this -i flag means that file.txt will be changed
# -i or --in-place erase the input file (use --in-place=.backup to keep a back-up)

# print to stdout all lines of file.txt which match some regex
# The example prints lines which begin with &quot;foo&quot; and end in &quot;bar&quot;
grep &quot;^foo.*bar$&quot; file.txt

# pass the option &quot;-c&quot; to instead print the number of lines matching the regex
grep -c &quot;^foo.*bar$&quot; file.txt

# Other useful options are:
grep -r &quot;^foo.*bar$&quot; someDir/ # recursively `grep`
grep -n &quot;^foo.*bar$&quot; file.txt # give line numbers
grep -rI &quot;^foo.*bar$&quot; someDir/ # recursively `grep`, but ignore binary files

# perform the same initial search, but filter out the lines containing &quot;baz&quot;
grep &quot;^foo.*bar$&quot; file.txt | grep -v &quot;baz&quot;

# if you literally want to search for the string,
# and not the regex, use `fgrep` (or `grep -F`)
fgrep &quot;foobar&quot; file.txt

# The `trap` command allows you to execute a command whenever your script
# receives a signal. Here, `trap` will execute `rm` if it receives any of the
# three listed signals.
trap &quot;rm $TEMP_FILE; exit&quot; SIGHUP SIGINT SIGTERM

# `sudo` is used to perform commands as the superuser
# usually it will ask interactively the password of superuser
NAME1=$(whoami)
NAME2=$(sudo whoami)
echo &quot;Was $NAME1, then became more powerful $NAME2&quot;

# Read Bash shell built-ins documentation with the bash `help` built-in:
help
help help
help for
help return
help source
help .

# Read Bash manpage documentation with `man`
apropos bash
man 1 bash
man bash

# Read info documentation with `info` (`?` for help)
apropos info | grep '^info.*('
man info
info info
info 5 info

# Read bash info documentation:
info bash
info bash 'Bash Features'
info bash 6
info --apropos bash
</code></pre><p>Source
<a href=https://learnxinyminutes.com/docs/bash/>https://learnxinyminutes.com/docs/bash/</a></p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://elvisfinol.com/tags/bash/>bash</a></li>
</ul>
</footer>
</article>
</main><footer class=footer>
<span>&copy; 2022 <a href=https://elvisfinol.com>Elvis Finol</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo Framework</a></span>
<span>&#183;</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.replaceState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>